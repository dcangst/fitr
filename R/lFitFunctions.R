#' fit growth curve
#'
#' fits a model to growth data. Outputs all fits as a \code{data.frame}
#'
#' @param data long-form data frame with growth data
#' @param w_size size of sliding window (number of datapoints)
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param method the method used to fit, at the moment only "lsw" for a linear sliding window fit.
#' @section Output:
#'    \code{data.frame} of with all fits for all possible windows
#' @keywords growthcurve
#' @export
gcfit	<-	function(data,w_size,od_name,time_name,method = "lsw") {

  if (method == "lsw"){
    od_colnr <- which(colnames(data) == od_name)
    time_colnr <- which(colnames(data) == time_name)
  
    data <- data[with(data, order(data[,time_colnr])), ]
    data$logODred <- log10(data[,od_colnr])
    filler <- rep(NA,nrow(data)-w_size)
    fits <- data.frame(minP=filler,nTime=filler,mumax=filler,intercept=filler,pearCoeff=filler,dt=filler, comment=filler)
  
  
    for (i in 1:(nrow(data)-w_size)) {
  
          data_subset <- data[i:(i+w_size-1),]
          
          if(length(na.omit(data_subset$logODred)) < w_size){
            fits[i,]$minP <- i
            fits[i,]$comment <- "missing data!"
            next
          }
          
          fit <- lm(data_subset$logODred ~ data_subset[,time_colnr],singular.ok=TRUE,na.action=na.omit)
  
          fits[i,]$minP  <- i #N/minP
          fits[i,]$nTime <-  length(data[,time_colnr]) #number of timepoints in growthcurve
          fits[i,]$mumax  <- fit$coefficients[[2]] #mumax
          fits[i,]$intercept  <- fit$coefficients[[1]] #intercept
          fits[i,]$pearCoeff  <- cor(1:w_size, data_subset$logODred) #pearCoeff
          fits[i,]$dt  <- log(2,10)/fit$coefficients[[2]] #dt
          fits[i,]$comment  <- "ok" # comment
         
      }
  } # method == "lsw"
     
  return(fits)

} # fn:lfit

#' pick best fits
#'
#' pick the 'most valid' fit. This will be the fit with the highest mumax and a correlation coefficient above \code{pearCoeff}
#'
#' @param fits \code{data.frame} containing fits generated by \code{\link{lfit}}
#' @param pearCutoff Only fits with a correlation coefficient higher than the cutoff are considered. Defaults to 0.95.
#' @section Output:
#'    \code{data.frame} with all fits from lfit
#' @keywords growthcurve
#' @export
pickfit <- function(fits,pearCutoff = 0.95) {

    fits <- fits[fits$pearCoeff>=pearCutoff,]
    best <- fits[fits$mumax==max(fits$mumax,na.rm=TRUE),]
    return(best)

} # fn:pickfit

#' plot fits generated with lfit and selected with pickfit
#'
#' plot all fits, or only a selection using the \code{select} argument.
#'
#' @param bestfit \code{data.frame} with best fit generated by \code{\link{pickfit}}
#' @param fits \code{data.frame} containing fits generated by \code{\link{lfit}}
#' @param data long-form data frame with growth data
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param select a vector containing IDs of a selection of fits to plot. Defaults to \code{FALSE}, showing all fits. IDs not found in \code{data} are quietly ignored.
#' @param interactive boolean; Should every plot be shown? Advance to next plot by clicking in plot area.
#' @section Output:
#'    none
#' @keywords growthcurve
#' @export
plotfit  <- function(bestfit,fits,data,od_name,time_name,select = FALSE,interactive = TRUE) {
	od_colnr <- which(colnames(data) == od_name)
  time_colnr <- which(colnames(data) == time_name)

  data <- data[with(data, order(data[,time_colnr])), ]
  
  if (class(fits)=="data.frame"){
    fits <- list(fits)
    attr(fits,"split_labels") <- data.frame(ID=data$ID[1])
    bestfit$ID <- data$ID[1]
    data$ID <- data$ID[1]
    interactive <- FALSE  
  }

  if (is.logical(select)) {
    IDs <- sort(unique(data$ID))
  } else {
    cat("Selected IDs for plotting: ",paste0(select,collapse=", "),"\n",sep="")
    data <- subset(data, ID %in% select)
    bestfit <- subset(bestfit, ID %in% select)
    IDs <- sort(unique(data$ID))    
  } 

  nFits <- dim(bestfit)[1]

  if (nFits != length(IDs)){stop("unequal dimensions of data and fits") }

  for (i in 1:nFits){
    
    data_sub <- subset(data, ID == IDs[i]) 
    bestfit_sub <- subset(bestfit, ID == IDs[i])
    fits_sub <- fits[[as.numeric(rownames(subset(attr(fits,"split_labels"),ID==IDs[i])))]]

    par(mfrow=c(2,1),oma=c(0,0,0,1),mar=c(4,4,4,0),mgp=c(3,1,0))
    printMain <- paste0(names(data_sub[,-c(od_colnr,time_colnr)]),
                       c(" = "),
                       data_sub[1,-c(od_colnr,time_colnr)],
                       collapse=" | "
                       )

    plot(data_sub[,time_colnr], log10(data_sub[,od_colnr]), xlab="time", ylab="OD600",type="b",main=printMain)
    #mtext(paste(names(data_sub[,-c(od_colnr,time_colnr)]),collapse="  |  "),side=3,line=1.5,cex=0.5)
    #mtext(paste(data_sub[1,-c(od_colnr,time_colnr)],collapse="  |  "),side=3,line=0.5,cex=0.5)
    #mtext(paste(names(bestfit_sub),collapse=" | "),side=1,line=4,cex=0.5)
    #mtext(paste(bestfit_sub,collapse=" | "),side=1,line=5,cex=0.5)
    abline(a=bestfit_sub$intercept ,b=bestfit_sub$mumax,col="red")
    printParams <- paste(
                    c("intercept =","mumax =", "dt =", "Pears. R ="),
                    signif(c(bestfit_sub$intercept,bestfit_sub$mumax,bestfit_sub$dt,bestfit_sub$pearCoeff),4)
                   )   
    legend("bottomright",legend=printParams,xjust=0.5, title="Best Fit:")
    color <- rgb((fits_sub$pearCoeff-min(fits_sub$pearCoeff))/(max(fits_sub$pearCoeff)-min(fits_sub$pearCoeff)),0,1-(fits_sub$pearCoeff-min(fits_sub$pearCoeff))/(max(fits_sub$pearCoeff)-min(fits_sub$pearCoeff)))
    plot(fits_sub$minP,fits_sub$mumax,col=color,xlab="sliding window start point",ylab="mumax")
    legend("topright",legend="color: Pears. R")
    points(bestfit_sub$minP,bestfit_sub$mumax,col="blue",pch=8,cex=1.5)
    #plot(fits_sub$minP,fits_sub$pearCoeff,col=color,xlab="sliding window start point",ylab="Pearsons correlation coefficient")
    #points(bestfit_sub$minP,bestfit_sub$pearCoeff,col="blue",pch=8,cex=1.5)
    if(interactive){
      cat("Showing Plot ",i," of ",nFits," (ID = ",IDs[i],"). Click in plot area for next plot.","\n",sep="")
      locator(1)
    }  
  }
  cat("done.","\n")

} #Â fn:plotfit

#' Wrapper function for automated growth curve fitting
#' 
#' @param data long-form data frame with growth data
#' @param w_size size of sliding window (number of datapoints)
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param pearCutoff Only fits with a correlation coefficient higher than the cutoff are considered. Defaults to 0.95.
#' @param method the method used to fit, at the moment only "lsw" for a linear sliding window fit.
#' @param parallel if \code{TRUE}, apply function in parallel, using parallel backend provided by \code{\link[foreach]{foreach}}.
#' @param progress name of the progress bar to use, see \code{\link[plyr]{create_progress_bar}}
#' @section Output:
#'    an object of class fitr.
#' @keywords growthcurve
#' @export
agcfit <- function(data,w_size,od_name,time_name,pearCutoff=0.95,method = "lsw",parallel=FALSE,progress="text"){
 
  if (parallel) {
    doParallel::registerDoParallel()
  }  
  
  cat("fitting growth curves...","\n"); flush.console()

  fits <- plyr::dlply(data,.(ID),gcfit,w_size=15,od_name=od_name,time_name=time_name,method = "lsw",.parallel=parallel,.progress=progress)

  cat("selecting best fits...","\n"); flush.console()

  best <- ldply(fits,pickfit,pearCutoff=pearCutoff,.progress=progress)

  parameter <- data.frame(
                          date = Sys.Date(),
                          nFits = dim(best)[1], 
                          w_size,
                          od_name,
                          time_name,
                          pearCutoff,
                          stringsAsFactors=FALSE
                         )

  out <- list(data=data,fits=fits,bestfits=best,parameter=parameter)
  class(out) <- "fitr"
  
  return(out)

} # fn:alfit

