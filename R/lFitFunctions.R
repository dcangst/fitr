#' fit growth curve
#'
#' fits a model to growth data. Outputs all fits as a \code{data.frame}
#'
#' @param data long-form data frame with growth data
#' @param w_size size of sliding window (number of datapoints)
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param trafo Data transformation, one of \code{"logNN0"} (for log(N/N0) transformation), \code{"log"} or \code{"none"}.
#' @section Output:
#'    \code{data.frame} of with all fits for all possible windows
#' @keywords fitr, growthcurve
#' @export
gcfit	<-	function(data,w_size,od_name,time_name,trafo="log") {

    od_colnr <- which(colnames(data) == od_name)
    time_colnr <- which(colnames(data) == time_name)
    
    data <- .gcDataTrafo(data,od_colnr,time_colnr,trafo)
    
    filler <- rep(NA,nrow(data)-w_size)
    fits <- data.frame(minP=filler,numP=filler,nTime=filler,mumax=filler,intercept=filler,adj.r.sq=filler,dt=filler,maxOD=max(data$ODtrans,na.rm=TRUE),trafo=trafo, comment=filler)
      
    for (i in 1:(nrow(data)-w_size)) {
  
          data_subset <- data[i:(i+w_size-1),]
          numP <- length(na.omit(data_subset$ODtrans))
          
          if(numP < 3){
            fits[i,]$minP <- i
            fits[i,]$comment <- "< 3 valid points for fit!"
            next
          }
          
          fit <- lm(data_subset$ODtrans ~ data_subset[,time_colnr],singular.ok=TRUE,na.action=na.omit)
  
          fits[i,]$minP  <- i #N/minP
          fits[i,]$numP <- numP
          fits[i,]$nTime <-  length(data[,time_colnr]) #number of timepoints in growthcurve
          fits[i,]$mumax  <- fit$coefficients[[2]] #mumax
          fits[i,]$intercept  <- fit$coefficients[[1]] #intercept
          fits[i,]$adj.r.sq  <- summary(fit)$adj.r.squared #adjusted R squared of fit
          fits[i,]$dt  <- log(2)/fit$coefficients[[2]] #dt
          fits[i,]$comment  <- "ok" # comment
         
      }

  return(fits)

} # fn:lfit

#' pick best fits
#'
#' pick the 'most valid' fit. This will be the fit with the highest mumax and an adjusted R squared above \code{RsqCutoff}
#'
#' @param fits \code{data.frame} containing fits generated by \code{\link{lfit}}
#' @param RsqCutoff Only fits with an adjusted R squared (see \code{\link{summary.lm}}) higher than the cutoff are considered. Defaults to 0.95.
#' @section Output:
#'    \code{data.frame} with all fits from lfit
#' @keywords fitr, growthcurve
#' @export
pickfit <- function(fits,min_numP,RsqCutoff = 0.95) {

    comment <- "ok"

    fits_rsq <- fits[is.na(fits$adj.r.sq)==FALSE,]
      if (dim(fits_rsq)[1]==0){
        comment <- "no valid fits"
      }
    fits_numP <- fits_rsq[fits_rsq$numP>=min_numP,]
      if (dim(fits_numP)[1]==0 & comment=="ok"){
        comment <- paste("no fits with >=",min_numP,"points")
      }
    fits_rsqC <- fits_numP[fits_numP$adj.r.sq>=RsqCutoff,]
      if (dim(fits_rsqC)[1]==0 & comment=="ok"){
        comment <- paste0("no fits with adj.r.sq >=",RsqCutoff," (max=",round(max(fits_numP$adj.r.sq,na.rm=TRUE),5),")")
      }

    if(comment != "ok"){
      best <- fits[1,]
      best[] <- NA
      best$comment <- comment
    } else {
      best <- fits_rsqC[fits_rsqC$mumax==max(fits_rsqC$mumax,na.rm=TRUE),]
    }
    
    return(best)

} # fn:pickfit

#' plot fits generated with lfit and selected with pickfit
#'
#' plot all fits, or only a selection using the \code{select} argument.
#'
#' @param bestfit \code{data.frame} with best fit generated by \code{\link{pickfit}}
#' @param fits \code{data.frame} containing fits generated by \code{\link{lfit}}
#' @param data long-form data frame with growth data
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param select a vector containing IDs of a selection of fits to plot. Defaults to \code{FALSE}, showing all fits. IDs not found in \code{data} are quietly ignored.
#' @param interactive boolean; Should every plot be shown? Advance to next plot by clicking in plot area.
#' @section Output:
#'    none
#' @keywords growthcurve
#' @export
plot_fitr  <- function(bestfit,fits,data,od_name,time_name,select = FALSE,interactive = TRUE) {
	od_colnr <- which(colnames(data) == od_name)
  time_colnr <- which(colnames(data) == time_name)

  data <- data[with(data, order(data[,time_colnr])), ]
  
  if (class(fits)=="data.frame"){
    fits <- list(fits)
    attr(fits,"split_labels") <- data.frame(ID=data$ID[1])
    bestfit$ID <- data$ID[1]
    data$ID <- data$ID[1]
    interactive <- FALSE  
  }

  if (is.logical(select)) {
    IDs <- sort(unique(data$ID))
  } else {
    cat("Selected IDs for plotting: ",paste0(select,collapse=", "),"\n",sep="")
    data <- subset(data, ID %in% select)
    bestfit <- subset(bestfit, ID %in% select)
    IDs <- sort(unique(data$ID))    
  } 

  nFits <- dim(bestfit)[1]

  if (nFits != length(IDs)){stop("unequal dimensions of data and fits") }

  for (i in 1:nFits){
    
    if(interactive){
      cat("Showing Plot ",i," of ",nFits," (ID = ",IDs[i],"). Click in plot area for next plot.","\n",sep="")
      locator(1)
    }

    data_sub <- subset(data, ID == IDs[i]) 
    bestfit_sub <- subset(bestfit, ID == IDs[i])
    if(bestfit_sub$comment != "ok"){
      par(mfrow=c(2,1),oma=c(0,0,0,1),mar=c(4,4,4,0),mgp=c(3,1,0))
      printMain <- paste0(names(data_sub[,-c(od_colnr,time_colnr)]),
                       c(" = "),
                       data_sub[1,-c(od_colnr,time_colnr)],
                       collapse=" | "
                       )
      plot(1,1)
      plot(1,1)
      next
    }
    fits_sub <- fits[[as.numeric(rownames(subset(attr(fits,"split_labels"),ID==IDs[i])))]]
    data_sub <- .gcDataTrafo(data_sub,od_colnr,time_colnr,bestfit_sub$trafo)

    par(mfrow=c(2,1),oma=c(0,0,0,1),mar=c(4,4,4,0),mgp=c(3,1,0))
    printMain <- paste0(names(data_sub[,-c(od_colnr,time_colnr)]),
                       c(" = "),
                       data_sub[1,-c(od_colnr,time_colnr)],
                       collapse=" | "
                       )

    plot(data_sub[,time_colnr], data_sub$ODtrans, xlab="time", ylab="OD600",type="b",main=printMain)
    abline(a=bestfit_sub$intercept ,b=bestfit_sub$mumax,col="red")
    printParams <- paste(
                    c("intercept =","mumax =", "dt =", "Pears. R ="),
                    signif(c(bestfit_sub$intercept,bestfit_sub$mumax,bestfit_sub$dt,bestfit_sub$adj.r.sq),4)
                   )   
    legend("bottomright",legend=printParams,xjust=0.5, title="Best Fit:")
    color <- .rgbColorGradient(fits_sub$adj.r.sq)
    plot(fits_sub$minP,fits_sub$mumax,col=color,xlab="sliding window start point",ylab="mumax")
    legend("topright",legend="color: adj. R squared")
    points(bestfit_sub$minP,bestfit_sub$mumax,col="blue",pch=8,cex=1.5)
   

  }
  cat("done.","\n")

} #Â fn:plotfit

#' Wrapper function for automated growth curve fitting
#' 
#' @param data long-form data frame with growth data
#' @param w_size size of sliding window (number of datapoints considered)
#' @param od_name name of column containing OD values
#' @param time_name name of column containing times (in units after start of experiment)
#' @param trafo Data transformation, one of \code{"logNN0"} (for log(N/N0)), \code{"log"} or \code{"none"}.
#' @param RsqCutoff Only fits with a correlation coefficient higher than the cutoff are considered. Defaults to \code{0.95}.
#' @param parallel if \code{TRUE}, apply function in parallel, using parallel backend provided by \code{\link[foreach]{foreach}}.
#' @param progress name of the progress bar to use, see \code{\link[plyr]{create_progress_bar}}
#' @param ... additional parameters passed to ply functions.
#' @section Output:
#'    an object of class fitr.
#' @keywords growthcurve
#' @export
d_gcfit <- function(data,w_size,od_name,time_name,trafo="log",min_numP=w_size,RsqCutoff=0.95,parallel=FALSE,progress="text",...){
 
  if (parallel) {
    doParallel::registerDoParallel()
  }  
  
  cat("fitting growth curves...","\n"); flush.console()

  fits <- plyr::dlply(data,.(ID),gcfit,w_size=15,od_name=od_name,time_name=time_name,trafo=trafo,.parallel=parallel,.progress=progress,...)

  cat("selecting best fits...","\n"); flush.console()

  best <- plyr::ldply(fits,pickfit,min_numP=min_numP,RsqCutoff=RsqCutoff,.progress=progress,...)

  parameter <- data.frame(
                          date = Sys.Date(),
                          nFits = dim(best)[1], 
                          w_size,
                          od_name,
                          time_name,
                          RsqCutoff,
                          trafo,
                          stringsAsFactors=FALSE
                         )

  out <- list(data=data,fits=fits,bestfits=best,parameter=parameter)
  class(out) <- "fitr"
  
  return(out)

} # fn:d_gcfit

